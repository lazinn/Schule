F13:
SELECT f.ArtikelID, f.bezeichnung, f.hersteller, SUM(r.menge) AS Gesamtmenge FROM fahrrad AS f JOIN rechnungspositionen AS r ON f.ArtikelID = r.ArtikelID 
GROUP BY f.ArtikelID;


F14
select m.Personalnr, m.Vorname, m.Nachname, COUNT(r.RechnungsID), SUM(r.Gesamtpreis) from mitarbeiter as m LEFT Join rechnungen as r On m.Personalnr = r.Personalnr GROUP By Personalnr;

F17:

geht nicht da wir keine Benutzerlogins in einer anwendung haben.
Wer angemeldet ist wäre über eine Programmierung einfach, indem man am anfang wo der benutzer sich anmeldet seine id als variable gespeichert wird.
SQL würde theoretisch über CURRENT_USER gehen, müsste aber die verknüpfung zwischen benutzernamen der DB und dem Mitarbeiternamen übereinstimmen.
Die jetzige Uhrzeit geht z.B. über CURRENT_DATE

F18:
SELECT f.Hersteller, f.Bezeichnung, fa.farbe, fa.Rahmenhöhe, ft.Name, (f.Listenpreis - (f.Listenpreis * 0.10)) as Aktionspreis
FROM fahrrad AS f JOIN fahrradmerkmale AS fa ON f.ArtikelID = fa.ArtikelID JOIN fahrradtypen AS ft ON fa.FahrradtypID = ft.TypID
WHERE fa.farbe = "blau" AND ft.Name = "E-Bike";

F19:
SELECT f.ArtikelID, f.bezeichnung, f.hersteller, SUM(r.menge) AS Gesamtmenge FROM fahrrad AS f JOIN rechnungspositionen AS r ON f.ArtikelID = r.ArtikelID Join rechnungen as re ON r.RechnungsID = re.RechnungsID
WHERE re.Rechnungsdatum BETWEEN '2024.05.01' and '2024.06.01' GROUP BY f.ArtikelID Limit 5;

es können in Phpmyadmin zwar abfragen gespeichert werden, allerdings muss man immer den ganzen Befehl ändern und kann nicht nur das Datum offenlegen.

F20:
SELECT f.ArtikelID, ft.Name, f.Bezeichnung, f.Hersteller, f.Listenpreis from fahrrad as f
JOIN fahrradmerkmale as fa ON f.ArtikelID = fa.ArtikelID JOIN fahrradtypen as ft ON fa.FahrradtypID = ft.TypID
WHERE Listenpreis BETWEEN '100' AND '2000';

F21:
SELECT k.KundenID, k.Vorname, k.Nachname, k.PLZ, k.Stadt, k.Straße, k.Hausnummer
FROM kunden AS k
WHERE NOT EXISTS (
    SELECT 1
    FROM rechnungen AS r
    WHERE r.KundenID = k.KundenID
    AND r.Rechnungsdatum > '2020-01-01'
)
ORDER BY k.Nachname ASC, k.Stadt ASC;

NF12:

Man man kann mit "SET AUTOCOMMIT = 1;" die automatische speicherung deaktviert.
Jetzt kann man änderungen machen, die nach einem Neustart nicht gespeichert währen.
Man startet jetzt mit "START Transaction;"
danach macht man seine änderungen.
Möchte man seine aktionen seit dem letzen commit rückgängig machen: "ROLLBACK;"
möchte man die Transaktion abschließen und speichern: "COMMIT;"

Wir haben das nirgens eingefügt aber theoretisch kann man das bei Rechnungserstellung in einer anwendung beim starten der aktion vorheriges anwenden.

Wenn man direkt an der Datenbank arbeitet, nicht über eine externe Anwendung, dann müsste man den autocommit jedes mal neu aus und wieder an machen,
da sonst alle änderungen nicht automatisch gespeichert werden.